# 스프링이란 ?

## 스프링 생태계

### - 필수

- <B>✨ 스프링 프레임 워크</B> : 스프링의 핵심
  - 핵심 기술: 스프링 DI 컨테이너, AOP, 이벤트, 기타  
    -> 핵심 기술에 초점을 맞춤, 나머지는 파생된 기술
  - 웹 기술: 스프링 MVC, 스프링 WebFlux
  - 데이터 접근 기술: 트랜잭션, JDBC, ORVM 지원, XML 지원
  - 기술 통합: 캐시, 이메일, 원격 접근, 스케줄링
  - 테스트: 스프링 기반 테스트 지원
  - 언어: 코틀린, 그루비
  - 최근에는 스프링 부트를 통해 편리하게 사용

<br>

- <b>스프링 부트</b> : 여러 스프링 기술을 편리하게 사용하도록 도와줌
  - 스프링을 편리하게 사용할 수 있도록 지원, 최근에 기본으로 사용
  - 단독으로 실행 가능한 스프링 어플리케이션 쉽게 생성 (Tomcat 같은 웹 서버 내장)
  - 손쉬운 빌드 구성 위한 starter 종속성 제공 (starter가 라이브러리 가져와 줌)
  - 스프링과 3rd parth(외부) 라이브러리 자동 구성 (버전 맞춰줌)
  - 메트릭, 상태 확인, 외부 구성 같은 프로덕션 준비 기능 제공 (모니터링에 도움)
  - 관례에 의한 간결한 설정 가능 (설정 쉬움, 수정도 간단)

<br>

### - 선택

- 스프링 데이터: CRUD 편리하게 사용할 수 있도록 도와줌
- 스프링 세션: 세션 기능 편리하게 사용할 수 있도록 도와줌
- 스프링 시큐리티: 보안 관련
- 스프링 Rest Docs: API 문서를 편리하게 도와줌
- 스프링 배치: 일괄 처리에 특화된 기술
- 스프링 클라우드: 클라우드에 특화된 기술

<br>

## 스프링의 핵심 컨셉

- 자바 언어 기반의 프레임워크
- 자바 언어의 가장 큰 특징 - 객체 지향 언어
- 좋은 객체 지향 애플리케이션 개발 가능

<br>

## 좋은 객체 지향 프로그래밍이란?

### 객체 지향 특징

- 추상화
- 캡슐화
- 상속
- 다형성

### 객체 지향 프로그래밍 특징

- 유연하고 변경이 용이
  1. 레고 블럭 조립하듯이
  2. 키보드, 마우스 갈아 끼우듯이
  3. 컴퓨터 부품 갈아 끼우듯이
  4. 컴포넌트를 쉽고 유연하게 변경하면서 개발할 수있는 방법

<br>

📍 다형성

- 역할과 구현을 분리 -> 단순, 유연해지며 변경도 편리
- 장점
  1. 클라이언트는 대상의 역할(인터페이스)만 알면 됨
  2. 클라이언트는 구현 대상의 내부 구조를 몰라도 됨
  3. 클라이언트는 구현 대상의 내부 구조가 변경되어도 no영향
  4. 클라이언트는 구현 대상 자체를 변경해도 no영향

<br>

- 역할 = 인터페이스
- 구현 = 인터페이스를 구현한 클래스, 구현 객체
- 객체 설계 시 역할과 구현 명확히 분리
- 역할 먼저 부여한 후 구현

- 객체의 협력이라는 관계부터 생각 : 클라이언트와 서버는 서로 협력관계
  > cf) 오버라이딩: 객체 재정의
- <b> 클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경 가능 </b>

<br>

### 역할과 구현 분리

- 유연, 변경 용이
- 확장 가능한 설계 (오버라이딩)
- 클라이언트에 영향 x
- 인터페이스 안정적으로 설계하는 것 중요 !

-> 인터페이스(역할) 자체가 변하면 클라이언트, 서버 모두 변경 발생

<br>

### 스프링과 객체 지향

- 스프링은 다형성 극대화 시킴
- 제어의 역전(IoC), 의존 관계 주입(DI)이 다형성 활용

<br>

## 좋은 객체 지향 설계의 5가지 원칙 (SOLID)

: 클린코드로 유명한 로버트 마틴이 정리

- SRP; 단일 책임 원칙
  - 한 클래스는 하나의 책임만 가져야 함
  - 중요한 기준은 변경, 변경이 있을 때 파급 효과가 적다면 GOOD
- OCP: 개방-폐쇄 원칙 ✨
  - 소프트웨어 요소는 확장에는 열려있으나, 변경에는 닫혀 있음 -> 다형성 생각
  - 인터페이스를 구현한 새로운 클래스 만들어 새로운 기능 구현
- LSP: 리스코프 치환 원칙
  - 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 변경 가능해야함
  - 다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 함 -> 다형성을 지원하기 위한 원칙
- ISP: 인터페이스 분리 원칙
  - 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 나음
  - 분리를 통해 클라이언트에 영향 주지않음
  - 인터페이스가 명확해지고, 대체 가능성 높아짐
- DIP: 의존관계 역전 원칙 ✨
  - 구현 클래스에 의존하지 말고, 인터페이스에 의존해야함
  - 역할에 의존해야함 !

<br>

- <B>정리</B>
  - 객체 지향의 핵심 : 다형성
  - 다형성 만으로는 쉽게 부품을 갈아 끼우듯이 개발 못함
  - 다형성 만으로는 구현 객체 변경 시 클라이언트 코드도 함께 변경
  - 다형성 만으로는 OCP, DIP 지키지 못함

<br>

## IntelliJ 단축키 (window)

- Generate : Alt + Insert (Getter, Setter, Construct 등)
- Import : Alt + Enter
- Introduce Variable : Ctrl + Alt + v (변수 이름 생성)
- 라인 복사 : Ctrl + d
- 라인 삭제 : Ctrl + y
- 라인 이동 : Alt + Shift

# application.properties 설정

- DDL generation
  - spring.jpa.generate-ddl=true
    - true 설정 시 해당 데이터를 근거로 서버 시작 시점에 DDL문 생성으로 DB에 적용
- spring.jpa.hibernate.ddl-auto=( )
  - 대부분 구현체로 Hibernate 사용하기 때문에, 이를 통해 보다 상세한 데이터베이스 초기화 전략 설정
  - none : 아무것도 실행 않함 (대부분의 DB 기본값)
  - create-drop: SessionFactory가 시작할 때 drop 후 create, 종료 때 drop 실행
  - create: SessionFactory가 시작될 때 데이터베이스 drop 실행 후 생성된 DDL 실행
  - update: 변경된 스키마 적용
  - validate: 변경된 스키마 있으면, 변경점 출력 후 어플리케이션 종료
